<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<title>The BGEN format</title>
	<link href="style.css" rel="stylesheet" type="text/css" />
	<script type="text/javascript" src="js/jquery-1.4.2.min.js"></script>
	<script type="text/javascript" src="js/local.js"></script>
</head>

<body>
  <div class="header">
    <div class="header_text">
      The BGEN format
    </div>

    <div class="header_subtext">
      A compressed binary format for typed and imputed genotype data
    </div>
  </div>
  <div class="main_text">
    <div id="overview">
		<div class="version">v1.2</div>
		<div class="version_overview">
			<b>This page documents version 1.2 of the BGEN format.</b>
			A later version is available - see <a href="bgen_format.html">here</a>.
			This version is backward-compatible with the
			earlier <a href="bgen_format_v1.1.html">v1.1 format spec</a> -
			this means every v1.1-format BGEN file is also a valid v1.2-format file.
			The v1.2 spec adds a new, more flexible layout for storing variant genotypes and haplotypes.
			(See below for a full history of versions of this spec).
			<p>
				<b>Note:</b> The UK Biobank full release imputed genotype data will be released in BGEN format, using
				using 8 bits per probability and zlib compression, as described in this specification.
				Phased haplotype data has also been released in BGEN format.
			</p>
			<p>
				The UK Biobank interim release imputed genotype data was released in <a href="bgen_format_v1.1.html">BGEN v1.1 format<a>.
			</p>
		</div>
	</div>

	<div id = "introduction" class="section">
		<h2>Introduction</h2>
		<p>
			Modern genetic association studies routinely employ data on tens to hundreds of thousands
			of individuals, genotyped or imputed at tens of millions of markers genome-wide.  Traditional
			data formats based on text representation of these data - such as
			the <a href="http://www.stats.ox.ac.uk/%7Emarchini/software/gwas/file_format.html">GEN</a>
			format output by <a href="https://mathgen.stats.ox.ac.uk/impute/impute_v2.html">IMPUTE</a>,
			or the <a href="http://ga4gh.org/#/fileformats-team">Variant Call Format</a>
			- are sometimes not well suited to these data quantities.  Indeed, for simple programs the time spent parsing
			these formats can dominate program execution time.
		</p>
		<p>
			This page describes a binary GEN file format (the "BGEN" format) which aims to address these problems.
			BGEN is a robust format that has been designed to have a specific blend of features that we believe make it
			useful for this type of study.  It is targetted for use with large, potentially imputed genetic datasets.
			Key features include:
			</ul>
				<li>The ability store both directly typed and imputed data.</li>
				<li>The ability to store both unphased genotypes and phased haplotype data.</li>
				<li>Small file sizes through the use of efficient, variable-precision packed bit representations and compression.</li>
				<li>The use of per-variant compression makes the format simple to index and easy to catalogue.</li>
			</ul>
		</p>
		<p>
			For example, the following plot shows the time taken to list variant identifying data - i.e. the genomic
			position, ID fields and alleles - for various common formats (Y-axis), against file size (X axis), for a dataset
			of 18,496 samples typed at 121,668 SNPs on chromosome 1.  Both variants of BGEN defined below are shown.
		</p>
		<div class="embedded_plot">
			<center>
				<img width = 400 height = 300 src="images/bgen_comparison.png"></img>
			</center>
		</div>
		<p>
			For <a href="https://www.cog-genomics.org/plink2/input#bed">PLINK binary (<code>.bed</code>) files</a>, identifying data is
			stored in a separate file (the <span class="monospace"><code>.bim</code></span> file) so the time is effectively zero.
			For text-based formats there is a significant trade-off between the use of file compression and
			read performance.  BGEN stores
			the entire dataset of 2,250 million genotypes in 334Mb, slightly over one bit per genotype, and in this test took 1.5s.
		</p>
		<p>
			(Performance optimisation of all formats may of course be possible, so the above plot
			will not represent the best possible timings, but should be regarded as illustrative.)
		</p>
		<p>
			The BGEN format has been used in several major projects, including the
			<a href="http://www.wtccc.org.uk/ccc2/">Wellcome Trust Case-Control Consortium 2</a>
			and the <a href="https://www.malariagen.net/projects/host">MalariaGEN</a> project.
			It has been adopted as the release format for genome-wide imputed genotypes
			for the <a href="http://www.ukbiobank.ac.uk">UK Biobank</a>.
		</p>
	</div>
	<div id = "contributors" class="section">
		<strong>Acknowledgements.</strong> The following people contributed to the design and implementation of the BGEN format:
        <ul>
                <li>
                    <a href="http://www.well.ox.ac.uk/~gav/">Gavin Band</a>
                </li>
                <li>
                    <a href="http://www.stats.ox.ac.uk/~marchini/">Jonathan Marchini</a>
                </li>
			</ul>
	</div>
	<div id = "tools" class="section">
		<h3>Software support</h3>
		<p>A freely available C++ implementation of the BGEN format is available
			<a href="http://bitbucket.org/gavinband/bgen">on bitbucket</a>.  This repository also contains a number of useful tools:
		</p>
		<dl>
			<dt><a href="http://bitbucket.org/gavinband/bgen/wiki/bgenix"><code>bgenix</code></a><dt>
				<dd>A tool which provides random access to data in a BGEN file by creating an index.</dd>
			<dt><a href="http://bitbucket.org/gavinband/bgen/wiki/cat-bgen"><code>cat-bgen</code></a><dt>
				<dd>A program to efficiently concatenate BGEN files.  Together with <code>bgenix</code> this effectively
					enables map/reduce pipelines that operate in parallel on seperate genomic regions.
					For example, we have found this useful for joining data into chromosomes after imputing genome-wide.</dd>
				<dt><A href="https://bitbucket.org/gavinband/bgen/wiki/edit-bgen"><code>edit-bgen</code></a></dt>
				<dd>A tool to (destructively) edit the BGEN header data.</dd>
			<dt><a href="http://bitbucket.org/gavinband/bgen/wiki/rbgen"><code>rbgen</code></a></dt>
				<dd>An R package that can be used to load data from an <code>bgenix</code>-indexed BGEN file into <a href="">R</a>.</dd>
		</dl>
		<p>
			In addition a set of example files and example programs, intended to demonstrate the API, are provided.
		</p>
		<p>
			Bgen support has been also implemented in several other software packages, click on the links below for more information.
		</p>
		<div class="logo_container">
			<a href="http://www.well.ox.ac.uk/~gav/qctool"><span style="font-family: Ariel, Helvetica, Tahoma">qctool v2</span></a>
			<a href="http://mathgen.stats.ox.ac.uk/genetics_software/snptest/snptest.html"><code>SNPTEST</code></a>
			<a href="http://www.cog-genomics.org/plink2"><code>PLINK</code></a>
			<a href="http://watson.hgen.pitt.edu/mega2.html"><code>Mega2</code></a>
			<a href="http://www.christianbenner.com/"><img src="images/ldstore.png" alt="LDSTORE" height=20></a>
			<a href="http://www.geenivaramu.ee/en/tools/regscan"><img src="images/regscan.png" height=25 alt="REGSCAN"></a>
			<a href="http://jmarchini.org/bgenie/"><code>BGENIE</code></a>
			<a href="http://hail.is"><img src="images/hail-logo-cropped.png" alt = "Hail"  height=20></a>
			<a href="http://data.broadinstitute.org/alkesgroup/BOLT-LMM/"><code>BOLT-LMM</code></a>
		</div>
		<p>
			(Please contact me if your software supports BGEN and you'd like it added to this list.)
		</p>
	</div>
    <div id="history" anchor="history" class="section">
      <h3>Change history</h3>

	  <div class = "boxed">
	  <dl>
	  <p>
		  A history of revisions of the v1.2 format spec is as follows:
	  </p>
	  <ul>
		  <dt>BGEN v1.2 (November 2016):</dt>
		  <dd>
			  Major update extending the BGEN format to add:
              <ul>
                <li>Support for variable ploidy and explicit missing data.</li>

                <li>Support for multi-allelic variants (e.g. complex structural
                variants).</li>

                <li>Allow for control over file size by supporting genotype probabilities
                stored at configurable precision.</li>

                <li>Support for storing sample identifiers.</li>
              </ul>
			  A draft version of this spec was published beginning May 2015.  The following changes have been made since the earlier draft:
			  <ul>
				  <li><b>2015-11-05</b> (<code>v1.2 beta1</code>): modified the treatment of missing data in Layout 2 (v1.2-style) variant data blocks.</li>
				  <li><b>2016-03-21</b> (<code>v1.2 beta2</code>): modified the order of stored probabilities for samples with ploidy greater than 2;
					  clarified specification of the <code>phased</code> flag for samples with ploidy less than 2.</li>
			  </ul>
		  </dd>
		  <dt>BGEN v1.1 (March 2012):</dt>
		  <dd>
              The first widely used version of the BGEN format.  The UK Biobank interim imputed data was released in this format.
			  Relative to v1.0, this version is designed to cope with the long alleles present at indels and
              structural variants in recent releases of the 1000 genomes project.  Features
			  of this version are:
              <ul>
                <li>Support for biallelic SNPs and indels with alleles of arbitrary length (up to 2<sup>32</sup>-1).</li>
                <li>Store probabilities to at least 4 decimal places worth' of accuracy</li>
              </ul>
		  </dd>
		  <dt>BGEN v1.0 (2009):</dt>
		  <dd>
			  The original BGEN format.  <am>This version is now deprecated and will be removed
			  from a future version of this spec; there probably aren't any files in the wild
			  in this format.</em>
		  </dd>
		</dl>
	</div>
	<div id="specification" class="section">
    <h2>Detailed specification</h2>

	    <h3>Overview</h3>

	    <p>A BGEN file consists of a header block, giving general infomation about the file,
			and an optional sample identifier block.  These are followed by a series of <em>variant data</em> blocks,
			stored consecutively in the file, which each contain data for a single genetic variant.  To allow for
			potential future additions to the spec, the first variant data block is located using an offset stored in
			the first four bytes of the file.
		</p>
		<p>
			The format in which variant data blocks are stored is determined by a set of flag bits stored in the header
			block.  Currently two formats are supported - Layout 1 blocks which are a direct translation to binary
			of the GEN format; and Layout 2 blocks, which are both more space-efficient and more flexible, including
			support for genotype and haplotype data, multi-allelic variants, and non-diploid samples.
			An older format, used in the
			v1.0 spec, is now deprecated and is no longer documented in this spec.
		</p>

	    <h3>Data types</h3>
		<div class="collapsible">
		    <p>All numbers in a BGEN file are stored as unsigned integers in little endian (least
		    significant byte first) order. This choice coincides with the memory layout used
		    on most common architectures - see the <a href=
		    "http://en.wikipedia.org/wiki/Endianness">wikipedia page</a> for more details.
			</p>
		    <p>Variant identifiers, chromosome identifiers, and other string fields are stored as a two- or four-byte integer length
				followed by the data itself (which does not include a C-style trailing zero byte).
			</p>
		    <p>Genotype probabilities are stored in an efficient packed bit representation described in detail below.</p>
		    <p>Finally, some fields in BGEN are interpreted as flags encoded as a bitmask.</p>
		</div>
    <h3>The first four bytes</h3>
	<div class="collapsible">
	    <p>The first four bytes of the file encode an unsigned integer indicating the offset,
	    relative to the 5th byte of the file, of the start of the first variant data block, or the end
	    of the file if there are 0 variant data blocks. For example, if this offset is 20 (the
	    minimum possible because the header block always has size at least 20) then the variant data
	    blocks start at byte 25.</p>

	    <center>
	      <table class="filespec">
	        <tr>
	          <th>No. of bytes</th>

	          <th>Description</th>
	        </tr>

	        <tr>
	          <td>4</td>

	          <td>An unsigned integer <em>offset</em> indicating the offset, relative to the
	          fifth byte of the file, of the first byte of the first variant data block (or the end of
	          the file if there are no variant data blocks).</td>
	        </tr>

	        <tr>
	          <th>4</th>

	          <th>TOTAL</th>
	        </tr>
	      </table>
	    </center>
	</div>
    <h3>The header block</h3>

    <p>The header block contains global information about the file, including the number of samples and the number
		of variant data blocks the file contains, and flags indicating how data is stored.
	</p>

    <table class="filespec">
      <tr>
        <th>No. of bytes</th>

        <th>Description</th>
      </tr>

      <tr>
        <td>4</td>

        <td>An unsigned integer <em>L<sub>H</sub></em> indicating the length, in bytes,
        of the header block. This must not be larger than <em>offset</em>.</td>
      </tr>

      <tr>
        <td>4</td>

        <td>An unsigned integer <em>M</em> indicating the number of variant data blocks stored in the
        file.</td>
      </tr>

      <tr>
        <td>4</td>

        <td>An unsigned integer <em>N</em> indicating the number of samples represented
        in the variant data blocks in the file.</td>
      </tr>

      <tr>
        <td>4</td>

        <td>'Magic number' bytes. This field should contain the four bytes 'b', 'g', 'e',
        'n'. For backwards compatibility, readers should also accept the value 0 (four
        zero bytes) here.</td>
      </tr>

      <tr>
        <td><em>L<sub>H</sub></em>-20</td>

        <td>Free data area. This could be used to store, for example, identifying
        information about the file</td>
      </tr>

      <tr>
        <td>4</td>

        <td>A set of <em>flags</em>, with bits numbered as for an unsigned integer. See
        below for flag definitions.</td>
      </tr>

      <tr>
        <th><em>L<sub>H</sub></em></th>

        <th>TOTAL</th>
      </tr>
    </table>

    <h4>Header block -- flag definitions</h4>

    <p>The following flags can be contained in the <em>flags</em> field in the header
    block. <b>Note</b>: bits and field values not specified here are reserved for possible future use;
	they should be set to zero.</p>

    <table class="filespec">
      <tr>
        <th>Bit</th>

        <th>Name</th>

        <th>Value</th>

        <th>Description</th>
      </tr>

      <tr>
        <td>0-1</td>

        <td><em>CompressedSNPBlocks</em></td>

        <td>0</td>

        <td>Indicates SNP block probability data is not compressed.</td>
      </tr>

      <tr>
        <td></td>

        <td></td>

        <td>1</td>

        <td>Indicates SNP block probability data is compressed using zlib's compress()
        function.</td>
      </tr>

      <tr>
        <td>2-5</td>

        <td><em>Layout</em><br />
        (previously called <em>LongIds</em>)</td>

        <td>0</td>

        <td>Indicates SNP blocks are layed out according to <b>Layout 0</b>, first used
			in the <a href="bgen_format_v1.0.html">v1.0 spec</a>. This allows only single-character alleles.
        <b>Use of this format is deprecated, in the sense that it should not be used for
        new files.</b> We will remove this from a future version of the spec.</td>
      </tr>

      <tr>
        <td></td>

        <td></td>

        <td>1</td>

        <td>Indicates SNP blocks are layed out according to <b>Layout 1</b>, i.e. as in
			the <a href= "bgen_format_v1.1.html">v1.1 spec</a>. This allows for
			multiple characters in alleles and is supported in SNPTEST from <a href=
        "https://mathgen.stats.ox.ac.uk/genetics_software/snptest/snptest.html">version
        2.3.0</a>, and in <a href=
        "http://www.well.ox.ac.uk/~gav/qctool/qctool.html">QCTOOL</a> from version
        1.1.</td>
      </tr>

      <tr>
        <td></td>

        <td></td>

        <td>2</td>

        <td>Indicates SNP blocks are layed out according to <b>Layout 2</b>, introduced in version 1.2 of
			the spec (i.e. in this document). This format supports multiple alleles, phased and
        unphased genotypes, explicit specification of ploidy and missing data, and
        configurable levels of compression.<br />
        It is recommended that all new files are stored with <em>Layout</em>=2.</td>
      </tr>

      <tr>
        <td></td>

        <td></td>

        <td></td>

        <td>Values &gt; 2 are reserved for future use.</td>
      </tr>

      <tr>
        <td>31</td>

        <td><em>SampleIdentifiers</em></td>

        <td>0</td>

        <td>Indicates sample identifiers are not stored in this file.</td>
      </tr>

      <tr>
        <td></td>

        <td></td>

        <td>1</td>

        <td>Indicates a sample identifier block follows the header. It is recommended
        that all new files are created with <em>SampleIdentifiers</em>=1.</td>
      </tr>
    </table>

    <h3>Sample identifier block</h3>

    <p>If <em>SampleIdentifiers</em>=1 in the flags field, the header block is immediately followed by a
    sample identifier block.  This stores a single identifier per sample.
	</p>
	<p><em>Note</em>: BGEN treats sample
	identifiers as a string of bytes, and does not impose any additional restrictions. 
	However, for the simplest interoperability with other software (e.g. for <a href=
    "http://www.r-project.org">R</a>'s <a href=
    "https://stat.ethz.ch/R-manual/R-devel/library/base/html/make.names.html">make.names</a>
    ) it is often sensible to restrict to ASCII alphanumeric characters, underscores, and full stop.
	</p>

    <table class="filespec">
      <tr>
        <th>No. of bytes</th>

        <th>Description</th>
      </tr>

      <tr>
        <td>4</td>

        <td>An unsigned integer <em>L<sub>SI</sub></em> indicating the length in bytes of
        the sample identifier block. This must satisfy the constraint
        <em>L<sub>SI</sub></em>+<em>L<sub>H</sub></em> &leq; <em>offset</em>.</td>
      </tr>

      <tr>
        <td>4</td>

        <td>An unsigned integer <em>N</em> indicating the number of samples represented
        in the file. This must be the same as the number <em>N</em> in the header
        block.</td>
      </tr>

      <tr>
        <td>2</td>

        <td>An unsigned integer indicating the length <em>L<sub>s1</sub></em> of the
        identifier of sample 1.</td>
      </tr>

      <tr>
        <td><em>L<sub>s1</sub></em></td>

        <td>Identifier of sample 1.</td>
      </tr>

      <tr>
        <td>2</td>

        <td>An unsigned integer indicating the length <em>L<sub>s2</sub></em> of the
        identifier of sample 2.</td>
      </tr>

      <tr>
        <td><em>L<sub>s1</sub></em></td>

        <td>Identifier of sample 2.</td>
      </tr>

      <tr>
        <td>...</td>

        <td></td>
      </tr>

      <tr>
        <td>2</td>

        <td>An unsigned integer indicating the length <em>L<sub>sN</sub></em> of the
        identifier of sample <em>N</em>.</td>
      </tr>

      <tr>
        <td><em>L<sub>sN</sub></em></td>

        <td>Identifier of sample <em>N</em>.</td>
      </tr>

      <tr>
        <th><em>L<sub>SI</sub></em> = 8 + 2&times;<em>N</em> +
        &sum;<sub>n</sub><em>L<sub>sn</sub></em></th>

        <th>TOTAL</th>
      </tr>
    </table>


    <h3>Variant data blocks</h3>

    <p>Following the header comes a sequence of <em>M</em> variant data blocks (where <em>M</em> is the number
		specified in the header block).
		This document describes SNP blocks for spec versions 1.1 and above.
		Version 1.0 is deprecated and should not be used in new files.

    <p>Variant data blocks are comprised of: a section of identifying data (containing variant IDs,
    position, and alleles), followed by a section containing the genotype probability
    data itself.  Most files will have  <em>CompressedSNPBlocks=1</em>, indicating
	that genotype probability data is stored compressed.  (The variant identifying data
	is never compressed, however.)
</p>

    <h4>Variant identifying data</h4>
	<div class="collapsible">
    <table class="filespec" align="center">
      <thead>
        <tr>
          <th>No. of bytes</th>

          <th>Description</th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>4</td>

          <td>The number of individuals the row represents, hereafter denoted <em>N</em>.
          This is only present if <em>Layout=1</em> (otherwise it appears instead in the
          genotype probability block below).</td>
        </tr>

        <tr>
          <td>2</td>

          <td>The length <em>L<sub>id</sub></em> of the variant identifier. (The variant
          identifier is intended to store e.g. chip manufacturer IDs for assayed
          SNPs).</td>
        </tr>

        <tr>
          <td><em>L<sub>id</sub></em></td>

          <td>The variant identifier.</td>
        </tr>

        <tr>
          <td>2</td>

          <td>The length <em>L<sub>rsid</sub></em> of the rsid.</td>
        </tr>

        <tr>
          <td><em>L<sub>rsid</sub></em></td>

          <td>The rsid.</td>
        </tr>

        <tr>
          <td>2</td>

          <td>The length <em>L<sub>chr</sub></em> of the chromosome</td>
        </tr>

        <tr>
          <td><em>L<sub>chr</sub></em></td>

          <td>The chromosome</td>
        </tr>

        <tr>
          <td>4</td>

          <td>The variant position, encoded as an unsigned 32-bit integer.</td>
        </tr>

        <tr>
          <td>2</td>

          <td>The number <em>K</em> of alleles, encoded as an unsigned 16-bit integer. If
          <em>Layout</em>=1, this field is omitted, and assumed to equal <em>2</em>.</td>
        </tr>

        <tr>
          <td>4</td>

          <td>The length <em>L<sub>a1</sub></em> of the first allele.</td>
        </tr>

        <tr>
          <td><em>L<sub>a1</sub></em></td>

          <td>The first allele.</td>
        </tr>

        <tr>
          <td>4</td>

          <td>The length <em>L<sub>a2</sub></em> of the second allele.</td>
        </tr>

        <tr>
          <td><em>L<sub>a2</sub></em></td>

          <td>The second allele.</td>
        </tr>

        <tr>
          <td>...</td>

          <td>...(possibly more alleles)...</td>
        </tr>

        <tr>
          <td>4</td>

          <td>The length <em>L<sub>aK</sub></em> of the <em>K</em>th allele.</td>
        </tr>

        <tr>
          <td><em>L<sub>aK</sub></em></td>

          <td>The <em>K</em>th allele.</td>
        </tr>
      <tfoot>
        <tr>
          <th>16 + 4<em>K</em> + <em>L<sub>id</sub></em> + <em>L<sub>rsid</sub></em> +
          <em>L<sub>chr</sub></em> + &sum;<sub>k</sub><em>L<sub>ak</sub></em> +
          <em>D</em></th>

          <th>TOTAL</th>
        </tr>
      </tfoot>
      </tbody>
    </table>
	</div>
	<h3 class=>Genotype data block (Layout 1)</h3>
	<div class="collapsible">
		<p>
			Layout 1 blocks are used when <em>Layout=1</em>.  Only two alleles (<em>K=2</em>) are supported.
			All samples are stored as if diploid; haploid samples should be stored as if having homozygous genotype.
			Missing samples are encoded as three zero probabilities.  This is a direct translation to binary format of
			a <a href="http://www.stats.ox.ac.uk/%7Emarchini/software/gwas/file_format.html">GEN</a> file.
		</p>
		<table class="filespec">
			<thead>
			<tr><th>No. of bytes</th><th>Description</th></tr>
			</thead>
			<tbody>
          <td><em>4</em></td>
	          <td>The total length <em>C</em> of the compressed genotype probability data for this variant.
				  Seeking forward this many bytes takes you to the next variant data block.
				  If <em>CompressedSNPBlocks=0</em> this field is omitted and the length of the uncompressed data
				  is <em>C=6N</em>.
			<tr><td><em>C</em></td><td>Genotype probability data for the SNP for each of the <em>N</em> individuals in
            the cohort in the format described below.
			If <em>CompressedSNPBlocks=0</em> this consists of <em>C=6N</em> bytes in the format
			described below.
			Otherwise this is <em>C</em> bytes which can be uncompressed
			using <a href="http://www.zlib.net">zlib</a> to form <em>6N</em> bytes stored in the format described below.
			(Zstandard compression, encoded by the value <em>CompressedSNPBlocks = 2</em>,
			is not supported for v1.1 style blocks.)
		</td></tr>
	</tbody>
			<tfoot>
			<tr><th><em>C</em> or <em>C+4</em><th>TOTAL</th></tr>
			</tfoot>
		</table>
		<h4>Probability data storage</h4>
            <p>
				For Layout 1 blocks, probability data is stored as a sequence of 2-byte unsigned integers.
				These should be interpreted in triples,
				the first member being the probability of a homozygous 'AA' allele,
				the second the probability of 'AB',
				the third the probability of 'BB', where A and B are the two alleles at the variant.
				When <em>CompressedSNPBlocks</em> is not set, these 6 * <em>N</em> bytes are
				stored in the file directly.  When <em>CompressedSNPBlocks>0</em>, these 6*<em>N</em>
				bytes are first compressed using <a href="http://www.zlib.net/">zlib</a>
				and the length of the compressed data is stored as the 4-byte integer <em>C</em>,
				followed by the compressed data itself.
            </p>
            <p>
				To convert the stored 2-byte integers into probabilities, the following calculation should be performed:
			</p>
			<ol>
				<li>Convert the number into a floating-point format (e.g. float or double).</li>
				<li>Divide by 32,768.</li>
			</ol>
			<p>
				Note that the range of a two-byte unsigned integer is 0 - 65,535 inclusive. Thus the resulting probabilities
                can take on values between 0 and 65,535/32768 ~ 1.9999 inclusive and they are accurate to four decimal places.
			</p>
			<p>
				To convert a floating point probability to its integer representation, do the following:
			</p>
			<ol>
				<li>Multiply by 32,768.</li>
				<li>Check that the number is in the half-open interval [0,65535.5) and round to the nearest integer.</li>
			</ol>
			<p>
				All numbers are stored in little-endian (least significant byte first) order.
				Probabilities for samples with missing genotype data should be stored as zero.
			</p>
	</div>

	<h3>Genotype data block (Layout 2)</h3>
	<div class="collapsible">
		<p>
		Layout 2 blocks are used when <em>Layout=2</em>.
		This format supports arbitrary numbers of alleles (up to 65535), samples of arbitrary ploidy (up to 63),
		and both phased and unphased data.
	</p>
	    <table class="filespec" align="center">
	      <thead>
	        <tr>
	          <th>No. of bytes</th>

	          <th>Description</th>
	        </tr>
	      </thead>

	      <tbody>
	        <tr>
	          <td><em>4</em></td>
			  <td>
				  The total length <em>C</em> of the rest of the data for this variant.
				  Seeking forward this many bytes takes you to the next variant data block.
			  </td>
	        </tr>
	        <tr>
	          <td><em>4</em></td>
	          <td>The total length <em>D</em> of the probability data after
	          uncompression.  If <em>CompressedSNPBlocks = 0</em>, this field is omitted and the total
			  length of the probability data is <em>D=C</em>.
			 </td>
	        </tr>

	        <tr>
	          <td><em>C</em> or <em>C-4</em></td>

	          <td>Genotype probability data for the SNP for each of the <em>N</em> individuals in
	            the cohort.  If <em>CompressedSNPBlocks = 0</em>, this is <em>D</em> bytes
				stored in the format described below.  If <em>CompressedSNPBlocks = 1</em>, this is <em>C-4</em> bytes
				which can be uncompressed using zlib to form <em>D</em> bytes in the format described below.
			</td>
	        </tr>
	      </tbody>
	    </table>

    <h4>Probability data storage</h4>
	<p>
		Layout 2 probability data storage is structured as described below.
		If <em>CompressedSNPBlocks = 0</em> the structure is stored directly, and <em>C</em> reflects the length of this structure.
		If <em>CompressedSNPBlocks > 0</em> the whole structure is stored after compression.  In this case
		<em>D</em> reflects the length of the uncompressed structure and
		the length of the compressed structure is <em>C-4</em>.
	</p>
    <table class="filespec">
      <thead>
        <tr>
          <th width='20%'>No. of bytes</th>

          <th>Description</th>
        </tr>
      </thead>

      <tbody>
        <tr>
          <td>4</td>

          <td>The number of individuals for which probability data is stored.  This must equal <em>N</em> as defined
			  in the header block.
		  </td>
        </tr>

        <tr>
          <td>2</td>

          <td>The number of alleles, encoded as an unsigned 16-bit integer.
			  This must equal <em>K</em> as defined in the variant identifying data block.</td>
        </tr>

        <tr>
          <td>1</td>

          <td>The minimum ploidy <em>P<sub>min</sub></em> of samples in the row. Values
          between 0 and 63 are allowed.</td>
        </tr>

        <tr>
          <td>1</td>

          <td>The maximum ploidy <em>P<sub>max</sub></em> of samples in the row. Values
          between 0 and 63 are allowed.</td>
        </tr>

        <tr>
          <td><em>N</em></td>

          <td>A list of <em>N</em> bytes, where the <em>n</em>th byte is an unsigned
          integer representing the ploidy and missingness of the <em>n</em>th sample.
          Ploidy (possible values 0-63) is encoded in the least significant 6 bits of
          this value. Missingness is encoded by the most significant bit; thus a value of
          1 for the most significant bit indicates that no probability data is stored for
          this sample.<br />
          (<b>Note</b>: there is no way to indicate that the ploidy itself is missing.)</td>
        </tr>

        <tr>
          <td>1</td>

          <td>Flag, denoted <em>Phased</em> indicating what is stored in the row.<br />
          If <em>Phased</em>=1 the row stores one probability per allele (other than the
          last allele) per haplotype (e.g. to represent phased data).<br />
          If <em>Phased</em>=0 the row stores one probability per possible genotype
          (other than the 'last' genotype where all alleles are the last allele), to
          represent unphased data.<br />
          Any other value for <em>Phased</em> is an error.</td>
        </tr>

        <tr>
          <td>1</td>

          <td>Unsigned integer <em>B</em> representing the number of bits used to store
          each probability in this row. This must be between 1 and 32 inclusive.</td>
        </tr>

        <tr>
          <td><em>X</em></td>

          <td>Probabilities for each possible haplotype (if <em>Phased</em>=1) or
          genotype (if <em>Phased</em>=0) for the samples. Each probability is stored in
          <em>B</em> bits. Values are interpreted by linear interpolation between 0 and
          1, i.e. value <em>b</em> corresponds to probability <em>b</em> / (
          2<sup>B</sup>-1 ). When storing the value, probabilities should be rounded
          according to the algorithm described below. Probabilities are stored
          consecutively for samples 1, 2, ..., <em>N</em>. For each sample the order of
          stored probabilities is described below. Probabilities for samples with missing
          data (as defined by the missingness/ploidy byte) are written as zeroes (note this represents
          a change from the earlier draft of this spec; see the <a href="#rationale">rationale</a> below).</td>
        </tr>
      </tbody>

      <tfoot>
        <tr>
          <th>
			  
			  <em>D=10+<em>N</em>+&Sum;<sub>i</sub><em>P</em><sub>i</sub></em>

          <th>TOTAL</th>
        </tr>
      </tfoot>
    </table>

    <h4>Per-sample order of stored probabilities</h4>

    <p>Consider a sample with ploidy <em>Z</em> and a variant with <em>K</em>
    alleles.</p>

    <ul>
      <li>For <b>phased data</b>, probabilities are stored in the order of haplotypes and
      then alleles, ie:

        <div class="displayFormula">
          <em>P<sub>11</sub></em>, <em>P<sub>12</sub></em>, ...,
          <em>P<sub>1(K-1)</sub></em>, <em>P<sub>21</sub></em>, ...,
          <em>P<sub>2(K-1)</sub></em>, ..., <em>P<sub>Z1</sub></em>, ...,
          <em>P<sub>Z(K-1)</sub></em>.
        </div>where <em>P<sub>ij</sub></em> is the probability that haplotype <em>i</em>
        has allele <em>j</em>. For each haplotype <em>i</em> the probability of the Kth
        allele (<em>P<sub>iK</sub></em>) is not stored; instead it is inferred as one
        minus the sum of other probabilities for that haplotype.  Thus a total of <em>Z(K-1)</em>
		probabilities are stored.
      </li>

      <li>
        <p>For <b>unphased data</b>, enumerate the possible genotypes as the set of <em>K</em>-vectors
			of nonnegative integers <em>(x<sub>1</sub>, x<sub>2</sub>, ..., x<sub>K</sub>)</em>,
			where <em>x<sub>i</sub></em> represents the count of the <em>i</em>-th allele in the genotype.
			Probabilities are stored in <a href="https://en.wikiversity.org/wiki/Lexicographic_and_colexicographic_order">colex order</a> of these vectors.  The last
			probability (corresponding the the <em>K</em>-th allele homozygotes) is not stored; instead
			it is inferred as one minus the sum of other probabilities.  Thus a total of
			<em>( Z+K-1 )</em> <code>choose</code> <em>( K-1 )</em>-1 probabilities is stored.
		</p>
		<p>
			<b>Example</b>. For example if <em>Z=3</em> and <em>K=3</em> then the enumerated genotypes
			with allele count representations are:
		</p>
		<table class = "allele_counts">
			<tr><th>Index</th><th>Genotype</th><th>Allele counts</th></tr>
			<tr><td>0</td><td>111</td><td>(3,0,0)</td>
			<tr><td>1</td><td>112</td><td>(2,1,0)</td></tr>
			<tr><td>2</td><td>122</td><td>(1,2,0)</td></tr>
			<tr><td>3</td><td>222</td><td>(0,3,0)</td></tr>
			<tr><td>4</td><td>113</td><td>(2,0,1)</td></tr>
			<tr><td>5</td><td>123</td><td>(1,1,1)</td></tr>
			<tr><td>6</td><td>223</td><td>(0,2,1)</td></tr>
			<tr><td>7</td><td>133</td><td>(1,0,2)</td></tr>
			<tr><td>8</td><td>233</td><td>(0,1,2)</td></tr>
			<tr><td>9</td><td>333</td><td>(0,0,3)</td></tr>
		</table>
		<p>
			The stored probabilities are thus
        <div class="displayFormula">
			<em>P<sub>111</sub></em>,<em>P<sub>112</sub></em>, <em>P<sub>122</sub></em>, <em>P<sub>222</sub></em>,
			<em>P<sub>113</sub></em>, <em>P<sub>123</sub></em>, <em>P<sub>223</sub></em>,
			<em>P<sub>133</sub></em>, <em>P<sub>233</sub></em>
        </div>
		<p>
			with <em>P<sub>333</sub></em> inferred as one minus the sum of the other probabilities.
		</p>
		<p>
			The colex order has the important property that the genotypes that for each <em>i</em> the genotypes carrying
			the <em>i</em>-th allele appear later in the order than those that carry only alleles <em>1,...,i-1</em>.
			See the <a href='#rationale'>rationale</a> below for
			a further discussion of this choice of storage order.
		</p>
      </li>
    </ul>
	
    <h4>Representation of probabilities</h4>
	<p>
		For both genotype and haplotype data, each probability value is stored using <em>B</em> bits as follows.
		An integer of length <em>B</em> bits can represent the values <em>0, ..., 2<sup>B</sup>-1</em> inclusive.
		To interpret a stored value <em>x</em> as a probability:
		<ol>
			<li>Convert <em>x</em> to an integer in floating-point representation.
			<li>Divide by <em>2<sup>B</sup>-1</em>.</li>
		</ol>
		Thus, probabilities stored in Layout 2 blocks take possible values of the form <em>x/(2<sup>B</sup>-1) &in; [0,1]</em>.
	</p>
	<p>
		Storing probabilities to the limited precision afforded by <em>B</em> bits requires a rounding rule, which we specify as follows.
		Given a vector <em>v=(v<sub>1</sub>, ...v<sub>d</sub>)</em> of <em>d</em>
		probabilities that sum to one, we round by finding the closest point to <em>v</em> of the
		form <em>x/(2<sup>B</sup>-1)</em> where the entries of <em>x</em> are
		nonnegative integers summing to (2<sup>B</sup>-1).  The integer vector <em>x</em> can be
		found by the following algorithm:
		<ol>
			<li>
				Multiply <em>v</em> by <em>2<sup>B</sup>-1</em>.
			</li>
			<li>
				Compute the total fractional part <em>F = &Sum;<sub>i</sub> (v<sub>i</sub>- </em>floor<em>(v<sub>i</sub>))</em>.
			</li>
			<li>
				Form <em>x</em> by rounding the <em>F</em> entries of <em>v</em> with the largest fractional parts up to the nearest integer,
				and the other <em>d-F</em> entries down to the nearest smaller integer.
			</li>
		</ol>
		The results of <a href="http://link.springer.com/article/10.1007/s10898-013-0126-2">Bomze et al, 2014</a>
		imply that <em>x/(2<sup>B</sup>-1)</em> is the nearest point to <em>v</em> that can be stored in the BGEN format with
		<em>B</em> bits.
	</p>
	<p>
		The maximum error in a probability stored using this rounding rule is <em>1/(2<sup>B</sup>-1)</em>.
	</p>
	<p>
		In practice we there may be some rounding error in probabilities input into the BGEN format.
		We therefore renormalise input probabilities to sum to one.
	</p>
</div>
<h2>Rationale and FAQ</h2>
<div id = "rationale">
	<p>
	<b>Q.</b> Should I use BGEN v1.1 or v1.2?  Or something else?
	</p>
	<p>
	<b>A.</b> The short answer is that we believe that for most purposes BGEN v1.2 is a
	good choice for storage of hard-called or imputed genotypes.
	</p>
	<p>For a more detailed answer, the following table tabulates features of various different formats:
	<table class = "filespec">
		<tr><th></th>
			<th>PLINK binary</th><th>GEN</th><th>BGEN v1.1</th><th>BGEN v1.2</th><th>VCF</th><th>BCF</th></tr>
		<tr><td>Supports unphased genotype calls</td>
			<td>&#10003;</td><td>&#10003;<sup>*</sup></td><td>&#10003;<sup>*</sup></td><td>&#10003;</td><td>&#10003;</td><td>&#10003;</td></tr>
		<tr><td>Supports unphased genotype probabilities</td>
			<td></td><td>&#10003;</td><td>&#10003;</td><td>&#10003;</td><td>&#10003;</td><td>&#10003;</td></tr>
		<tr><td>Supports NULL/outlier probability<br /><small>e.g. NULL class from CHIAMO / GenoSNP</small></td>
			<td></td><td>&#10003;</td><td>&#10003;</td><td></td><td>&#10003;</td><td>&#10003;</td></tr>
		<tr><td>Supports non-diploid samples</td>
			<td></td><td>&dagger;</td><td><sup>&dagger;</sup></td><td>&#10003;</td><td>&#10003;<sup>&Dagger;</sup></td><td>&#10003;<sup>&Dagger;</sup></td></tr>
		<tr><td>Supports phased data?</td>
			<td></td><td></td><td></td><td>&#10003;</td><td>&#10003;<sup>&Dagger;</sup></td><td>&#10003;<sup>&Dagger;</sup></td></tr>
		<tr><td>Supports multi-allelic variants</td>
			<td></td><td></td><td></td><td>&#10003;</td><td>&#10003;</td><td>&#10003;</td></tr>
		<tr><td>Efficient representation?</td>
			<td>&#10003;</td><td></td><td>&#10003;</td><td>&#10003;</td><td></td><td>&#10003;</td></tr>
	</table>
	<p>
		<small>
		<sup>*</sup>Hard-called genotypes are converted to probabilities in GEN and BGEN v1.1.
		<sup>&dagger;</sup>By convention, males on the X chromosome are stored as homozygote females in GEN and BGEN v1.1.
		<sup>&Dagger;</sup>At the time of writing, the storage of genotype likelihoods and probabilities for non-diploid samples
		and/or phased data in VCF/BCF is not fully specified.
	</small>
	</p>
	<p>
		Thus BGEN v1.2 is appropriate except for storing genotype probabilities from cluster-based calles such as
		<a href="https://mathgen.stats.ox.ac.uk/genetics_software/chiamo/chiamo.html"><code>CHIAMO</code></a>
		or <a href="http://www.stats.ox.ac.uk/~giannoul/GenoSNP/"><code>GenoSNP</code></a>,
		which can assign nonzero probability to a NULL or outlier class.  Use BGEN v1.1 or another format for these data.
	<p>
		Another consideration over what to use is tool support.  Support for BGEN v1.1 has been available for some time in
		QCTOOL, SNPTEST and other packages including PLINK.  Support for BGEN v1.2 is becoming available across a range of tools
		mid-2016.  We expect tool support for BGEN to continue to increase in future, driven in part by the use of
		BGEN for the UK Biobank data releases and the <a href="http://bitbucket.org/gavinband/bgen">availability of a reference implementation</a>.
	</p>
	<b>Q.</b> Why compress the data for each variant seperately?  Doesn't this end up using more space?
	</p>
	<p>
	<b>A.</b> Compressing each variant seperately has the advantage that the variant identifying data fields -
	which are stored uncompressed in BGEN - can be efficiently accessed without decompressing the whole file.
	It's true that theoretically higher rates of compression could be acheived by compressing as much data as possible.
	However, for large cohorts, each variant has plenty of data to compress, so the difference is expected to be small.
	(Alternative indexing approaches - like <a href="bgzip">bgzip</a>, which
		compresses data in blocks - also incur a size overhead.)
	</p>
	<p>
	<b>Q.</b> Why store the number of individuals on each row?  Why store the number of alleles twice?  Doesn't this waste space?
	</p>
	<p>
	<b>A.</b> Yes, each repeated field wastes 4 bytes per variant.  However, this is expected to be a tiny fraction of overall file size.
	The inclusion of repeated fields makes parsing simpler (since parsers don't need to be stateful) and also provides a useful way
	of testing that file structure is correct.
	</p>
	<p>
	<b>Q.</b> (For Layout 2 variant data blocks) Why the choice of colex order of genotypes?
	</p>
	<p>
	<b>A.</b> Several considerations motivated this choice - including simplicity of specification, ease of implementation,
	and compatibility with established standards.
	</p>
	<p>
		The colex order coincides with the order specified for 
		<code>GL</code> and <code>GP</code> fields for diploid samples in the <a href="https://samtools.github.io/hts-specs/">VCF</a>.  (At the time of writing the VCF specification of this field
		only applies to diploid samples).  This makes it easy to convert between BGEN and VCF formats.
	</p>
	<p>
	The chosen order has a useful 'nesting' property: adding an allele does not change the order of probabilities for
	genotypes not carrying the new allele.  More precisely, at a variant with <em>K+1</em> alleles, genotypes
	carrying only alleles among the first <em>K</em> appear earlier in the ordering than
	those carrying the <em>K</em>th allele - and with the same order as if the 'extra' allele wasn't present.
	A practical consequence of this is that mapping of each genotype to the index of
	the corresponding probability can be accomplished using a single lookup table that is independent of <em>K</em>
	(though it does depend on the ploidy).  We used such a lookup table in the
	<a href="https://bitbucket.org/gavinband/qctool/src/tip/genfile/src/ToGP.cpp">QCTOOL implementation</a> to convert hard-called
	genotypes to probabilities. 
	</p>
	<p>
	<b>Q.</b> (For Layout 2 variant data blocks) Why omit the last probability instead of the first?
	</p>
	<p>
	<b>A.</b> The intention is to make parsing the file as simple and fast as possible.  If we omitted the first probability,
	parsers would have to read and store all the other probabilities before computing and emitting
	the first probability.  With the scheme described here, parsers can simply emit the probabilities as they are read from the file,
	before finally emitting the last probability as one minus the sum of the stored probabilities.
	</p>
	<b>Q.</b> (For Layout 2 variant data blocks) Why store dummy zero data for samples with missing genotypes?
    Doesn't this increase file size unneccessarily?
	</p>
	<p>
	<b>A.</b>
 		(Note this behaviour was changed in the beta version of the spec relative to the earlier draft.)
		The intention is to make parsing the file as simple and fast as possible.  One option for loading genotypes
		from a BGEN file is simply to load the uncompressed genotype data into memory.  Potentially, encoded genotypes could
		then be used directly, e.g. as keys in a lookup table.  Storing placeholder data for missing samples
		makes this simpler to implement by maintaining a predictable index for the data for each sample within the encoded
		representation.  (We note this will be more complicated if ploidy varies across samples).
	</p>
</div>
</body>
</html>
